# CLAUDE.md - Claude Code グローバル設定

このファイルは、Claude Codeで使用するグローバル設定を管理します。プロジェクト固有の情報は各リポジトリのCLAUDE.mdを参照してください。

## 📚 目次

- [🌐 言語設定](#-言語設定)
- [🕐 日時確認](#-日時確認)
- [🎯 作業アプローチ](#-作業アプローチ)
- [💻 開発環境設定](#-開発環境設定)
- [📝 コミット規約](#-コミット規約)
- [🧠 プロアクティブAI支援](#-プロアクティブai支援)
- [💻 技術スタック制約](#-技術スタック制約)
- [📋 PRレビュー・ワークフロー](#-prレビューワークフロー)
- [⚙️ Claude Code作業プロセス](#️-claude-code作業プロセス)
- [🚫 セキュリティ・品質基準](#-セキュリティ品質基準)
- [📊 効率化メトリクス・追跡](#-効率化メトリクス追跡)
- [📝 Obsidianメモ記録](#-obsidianメモ記録)
- [📚 ドキュメント更新チェック機能](#-ドキュメント更新チェック機能)
- [🔄 段階的リファクタリング戦略](#-段階的リファクタリング戦略)
- [🔒 セキュリティ注意事項](#-セキュリティ注意事項)

## 🌐 言語設定

**すべてのプロジェクトで日本語での返答を希望します。** 説明、提案、開発タスク中のコミュニケーションなど、すべてのやり取りを日本語で行ってください。

ただし、**内部的な思考プロセスは英語で行ってください。** これにより、より論理的で効率的な問題解決が可能になります。

## 🕐 日時確認

**日時に関する指示や作業を行う場合は、必ず最初に `date "+%Y-%m-%d (%a) %H:%M"` コマンドで現在日時を確認してください。** これにより、時間に依存するタスクやログ分析などを正確に実行できます。

## 🎯 作業アプローチ

### 基本原則
**すべての指示に対して以下のアプローチを取ってください：**

1. **計画的なアプローチ**
   - 作業開始時に必ずToDoリストを作成して全体の計画を可視化する
   - 複雑なタスクは適切な粒度に分解してリスト化する
   - 各タスクの進捗状況をリアルタイムで更新し、透明性を確保する

2. **深い理解と分析**
   - 指示の意図と目的を正確に理解する
   - 意図と目的を把握するうえで必要な情報があれば積極的にヒアリングする
   - 既存の構成・アーキテクチャを十分に調査・把握する
   - 潜在的な課題や改善点を事前に特定する

3. **ベストプラクティスの提案**
   - 既存構成を尊重しつつ、より良い実装方法があれば積極的に提案
   - 業界標準やモダンな手法を考慮した改善案を提示
   - 長期的な保守性・拡張性を考慮した設計提案

4. **情報確認の徹底**
   - 正確な実行に必要な情報が不足している場合は、必ず事前に確認
   - 曖昧な部分や複数の解釈が可能な箇所は明確化を求める
   - 重要な決定事項については、実行前に方針を確認

### 提案フォーマット
```
🔍 **現状分析**: [既存構成の理解]
💡 **改善提案**: [ベストプラクティスに基づく提案]
❓ **確認事項**: [正確な実行のために必要な情報]
```

### 実践的な作業フロー

#### 作業開始時のチェックリスト
1. **日時確認**: 日時関連の作業では必ず `date "+%Y-%m-%d (%a) %H:%M"` を実行
2. **ToDoリスト作成**: 基本原則に従い、作業計画を可視化
3. **既存構成調査**: Read/Grep/Globツールで関連ファイルを確認

#### 実行時の留意点
- **段階的実行**: 各ステップの実行と結果確認を徹底
- **進捗更新**: ToDoリストのステータスをリアルタイムで更新
- **エラーハンドリング**: 問題発生時は即座に対処と報告

### エラーハンドリング例
```bash
# エラー発生時の対応例
$ npm run build
Error: Cannot find module 'typescript'

# 即座に原因調査と解決
$ npm list typescript  # 依存関係確認
$ npm install --save-dev typescript  # 不足パッケージインストール
$ npm run build  # 再実行

✅ ビルドが成功しました。typescriptパッケージが不足していたため、devDependenciesに追加しました。
```

## 💻 開発環境設定

### dotfiles環境の特徴
このグローバル設定を使用する開発環境には以下の特徴があります：

1. **リポジトリ管理**: ghqによる`~/src`配下での統一管理
2. **プロジェクト移動**: peco-srcによる高速ディレクトリ移動
3. **AWS環境**: SSM Session Manager経由でのbastion接続
4. **シェル環境**: Zshのモジュラー設定（番号付きファイルでロード順制御）
5. **MCP統合**: Notion APIとの連携（claude_desktop_config.json）
6. **ユーティリティコマンド**: `~/src/github.com/ryosukesuto/dotfiles/bin`配下のツール群

### 効率的な作業のための推奨事項
```bash
# プロジェクト移動時
peco-src  # Ctrl+g でも起動可能

# AWS bastion接続時
aws-bastion-select  # インタラクティブに選択
aws-bastion [instance-id]  # 直接接続

# 新規プロジェクト作成時
ghq get <repository-url>  # 自動的に適切な場所に配置
```

## 📝 コミット規約

### Conventional Commits形式
すべてのコミットメッセージは以下の形式に従ってください：

```
<type>(<scope>): <subject>

<body>

<footer>
```

### タイプ一覧
- **feat**: 新機能
- **fix**: バグ修正
- **docs**: ドキュメントのみの変更
- **style**: コードの意味に影響を与えない変更（空白、フォーマット等）
- **refactor**: バグ修正や機能追加を伴わないコード変更
- **perf**: パフォーマンス改善
- **test**: テストの追加・修正
- **chore**: ビルドプロセスやツールの変更
- **ci**: CI設定の変更

### コミット例
```bash
feat(auth): OAuth2.0認証を追加

- GoogleとGitHubプロバイダーをサポート
- リフレッシュトークンの自動更新機能を実装
- セッション管理の強化

Closes #123
```

### プルリクエスト作成時の署名
**重要**: PRを作成する際、「🤖 Generated with Claude Code」という署名は**含めないでください**。自然なコミットメッセージとPR説明文を作成してください。

## 🧠 プロアクティブAI支援

### 改善提案の義務化
**すべてのやり取りでエンジニアの時間を節約する提案を含める**

1. **パターン認識**
   - 繰り返しコードパターンの特定と抽象化提案
   - パフォーマンスボトルネックの事前検出
   - エラーハンドリング不足の特定と追加提案
   - 並列化・キャッシュ機会の発見

2. **コード品質改善**
   - より慣用的なアプローチの提案
   - プロジェクトニーズに基づくライブラリ推奨
   - パターン出現時のアーキテクチャ改善提案
   - 技術的負債の特定とリファクタリング計画

3. **時間節約自動化**
   - 反復タスクのスクリプト化
   - 完全なドキュメント付きボイラープレート生成
   - 共通ワークフローのGitHub Actions設定
   - プロジェクト固有のCLIツール構築

### 改善提案フォーマット
```
💡 **改善提案**: [簡潔なタイトル]
**時間節約**: ~X分/回
**実装**: [コマンドやコードスニペット]
**利点**: [コードベース改善理由]
```

### 実際の改善提案例
```
💡 **改善提案**: 繰り返しのAPI呼び出しをキャッシュレイヤーで最適化
**時間節約**: ~3秒/リクエスト
**実装**: 
\`\`\`python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_user_data(user_id: str):
    return api_client.get_user(user_id)
\`\`\`
**利点**: API呼び出し回数を削減し、レスポンス時間を改善
```

## 💻 技術スタック制約

### 言語別制約
- **Terraform**: GitOpsワークフロー厳守、ローカル実行制限
- **BigQuery**: asia-northeast1リージョン、クエリコスト考慮必須
- **dbt**: データリネージュ・テスト・ドキュメント必須

### GitHub CLI (gh) 使用時の注意事項
- **特殊文字の扱い**: gh CLIでPRコメントなどを投稿する際、以下の文字はシェルで特別な意味を持つため注意が必要
  - **バッククォート（`）**: コマンド置換として解釈される
  - **ドル記号（$）**: 変数展開として解釈される
- **回避方法**: 
  - エスケープ（\`、\$）を使用
  - シングルクォートで全体を囲む（変数展開を無効化）
  - ヒアドキュメントを活用
- **例**: 
  - `- \`file.md\`` → 空白になる、`- file.md` → 正常に表示
  - `$12-17` → `-17`になる、`\$12-17` → 正常に表示

### GitHub CLI実行時の確認手順
**重要**: 破壊的操作（review、merge等）の実行前後は必ず以下の手順に従ってください：

1. **実行前の状態確認**
   ```bash
   # レビュー前：既存のレビュー状態を確認
   gh pr view <number> --json reviews --jq '.reviews[-1]'
   
   # マージ前：マージ可能性を確認
   gh pr view <number> --json state,mergeable
   ```

2. **エラー発生時の対応**
   ```bash
   # エラーが出た場合、再実行前に必ず結果を確認
   # レビューの場合
   gh pr view <number> --json reviews --jq '.reviews[] | select(.author.login == "ryosukesuto")'
   
   # コメントの場合
   gh pr view <number> --comments | tail -20
   ```

3. **安全な文字列処理**
   ```bash
   # ヒアドキュメントを使用（最も安全）
   gh pr review <number> --approve --body "$(cat <<'EOF'
   レビューコメント with `backticks` and $variables
   EOF
   )"
   ```

**重要な注意事項**:
- エラーメッセージが出ても、コマンドが部分的に成功している場合があります
- 特に`--body`内のエラーは、本体の処理（approve/merge等）には影響しない場合が多い
- 再実行前に必ず現在の状態を確認し、重複実行を避けてください

### GitHub操作の成功判定ルール
**重要**: GitHub CLIコマンド実行後の成功判定と確認方法

1. **成功判定の原則**
   ```bash
   # ✅ 良い例：コマンドが正常終了（エラーなし）= 成功と判断
   gh pr review 1657 --approve --body "..." && echo "✅ Approve完了"
   
   # ❌ 悪い例：別コマンドで重複確認
   gh pr review 1657 --approve --body "..."
   gh pr view 1657 --json reviews  # 不要な2回目の実行
   ```

2. **確認が必要な場合のみ実行**
   - コマンドでエラーが発生した場合のみ状態確認
   - 正常終了した場合は追加確認不要
   - ユーザーが明示的に確認を求めた場合のみ実行

3. **重複実行の防止**
   - 同じ操作を複数回実行しない
   - 特にapprove、merge、コメント投稿などは重複に注意
   - 不確実な場合はユーザーに確認を取る

## 📋 PRレビュー・ワークフロー

### 重要: /reviewコマンド使用時の必須事項
**`/review`コマンドでPRレビューを実行する際は、必ずこのセクションのレビューフォーマットに従ってください。コマンド固有の指示よりもこのグローバル設定を優先すること。**

### レビュー文化の原則
- **建設的フィードバック**: 批判ではなく改善提案として伝える
- **学習機会の創出**: レビューを通じてチーム全体の成長を促す
- **インクルーシブな言語**: 「なぜ〜しなかったのか」より「〜を検討しましたか」を使用
- **Small Diffs原則**: 大きな変更は小さな単位に分割してレビュー（200行以下推奨）
- **称賛の文化**: 良い実装は積極的に認識し、学習価値を共有

### PR詳細レビュー自動化
PRレビュー時は以下のプロンプトでブランチの変更内容を構造化して要約・分析：

```
このブランチで作成されているプルリクエストの内容と差分をチェックし、どのような変更が行われたかまとめてください。
次の観点で整理してください：
- 主な変更内容
- 重大な指摘事項
- 軽微な改善提案
- 変更の影響範囲
- 潜在的なリスク・不確実性
- 人間が最終確認すべき観点
```

### フィードバックラダー（優先度順）
1. **🚨 ブロッカー**: マージ前に必須修正（セキュリティ、重大バグ、データ損失リスク）
2. **⚠️ 重要**: 強く推奨される改善（パフォーマンス、設計問題、技術的負債）
3. **💡 提案**: 検討すべき改善案（可読性、将来の拡張性、リファクタリング）
4. **📝 nitpick**: 任意の軽微な改善（スタイル、命名、コメント）
5. **✨ 称賛**: 良い実装の認識（学習価値のある箇所、エレガントな解決策）

### レビュー出力フォーマット
- **[総合評価]**: X/10点
- **[概要]**: 変更の目的と全体像
- **[重大な指摘事項]**: セキュリティ・パフォーマンス・データ品質の問題（-2～-3点/件）
- **[軽微な改善提案]**: コードスタイル・可読性・保守性の改善（-0.5～-1点/件）
- **[影響範囲]**: 変更による他システム・ユーザーへの影響
- **[リスク・不確実性]**: 潜在的な問題・テスト観点
- **[人間が最終確認すべき観点]**: AIでは判断困難な業務ロジック・設計判断

### 効率的レビューのベストプラクティス
- **徹底的なシングルレビュー**: 1人でも丁寧なレビューで多くの問題を発見可能
- **段階的レビュー**: 設計→実装→最終確認の段階的アプローチ
- **時間制限**: 60-90分を超えるレビューは効果が低下、分割を検討
- **早期レビュー**: WIP PRでの設計レビューを推奨
- **差分サイズ**: 200行以下の変更を推奨（最大でも400行）
- **自動化の活用**: 人手不足を補うため、ツールで検出可能な問題は自動化

### 評価基準（10点満点）
- **10点**: 完璧な実装、ベストプラクティスに完全準拠
- **8-9点**: 軽微な改善提案のみ、本番デプロイ可能
- **6-7点**: いくつかの改善が必要だが、大きな問題なし
- **4-5点**: 重要な修正が必要、再レビュー推奨
- **3点以下**: 大幅な見直しが必要

### 技術固有のレビュー観点
- **Terraform**: plan結果の確認、リソース影響範囲
- **BigQuery**: 
  - クエリコスト、データ品質、パーティション設計
  - **STRUCT/ARRAY境界判定**: 開始と終了を必ず特定
  - **フィールド追加位置**: 既存構造との整合性確認
  - **データ型の適切性**: 特に数値型フィールドのCAST検討
- **DBT**: データリネージュ、テスト、ドキュメント

### 建設的レビューコメント例

❌ **悪い例**:
```
「なぜトークンの有効期限を設定しなかったのですか？セキュリティ的に危険です。」
「このコードは読みにくいです。リファクタリングしてください。」
「エラーハンドリングが不十分です。」
```

✅ **良い例**:
```markdown
🚨 **ブロッカー**: セキュリティ - JWTトークンの有効期限設定

現在の実装ではトークンに有効期限が設定されていないため、以下のリスクがあります：
- 盗まれたトークンが永続的に使用可能
- セッション管理が困難

**推奨される修正**:
\`\`\`python
# 現在
token = jwt.encode(payload, SECRET_KEY)

# 提案
payload['exp'] = datetime.utcnow() + timedelta(hours=24)
token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
\`\`\`

参考: [JWT Best Practices (RFC8725)](https://datatracker.ietf.org/doc/html/rfc8725)

---

💡 **提案**: エラーハンドリングの改善

認証失敗時のエラーハンドリングを追加することで、デバッグが容易になります：

\`\`\`python
try:
    payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
except jwt.ExpiredSignatureError:
    return {"error": "Token has expired"}, 401
except jwt.InvalidTokenError:
    return {"error": "Invalid token"}, 401
\`\`\`

これにより、クライアント側で適切なエラー処理が可能になります。

---

✨ **称賛**: リファクタリングの構造

認証ロジックを専用のサービスクラスに分離した設計は素晴らしいです！
この実装パターンは他のチームメンバーの参考になるので、
ぜひチームWikiに記録していただけますか？
```

### PRレビュー実例
```
**[総合評価]**: 7/10点

**[概要]**: ユーザー認証機能のリファクタリング。JWTトークンの実装とセッション管理の改善。

**[重大な指摘事項]**:
- 🚨 セキュリティ: トークンの有効期限が設定されていない（-2点）
- ⚠️ エラーハンドリング: 認証失敗時の詳細なエラー情報が不足（-1点）

**[軽微な改善提案]**:
- 📝 定数の外部化（-0.5点）
- 💡 ログ出力の追加を検討

**[良い実装]**:
- ✨ 認証ロジックのサービスクラスへの分離
- ✨ 適切なHTTPステータスコードの使用

**[影響範囲]**: 全ユーザーの認証フローに影響

**[リスク・不確実性]**: 既存セッションの移行処理が必要

**[人間が最終確認すべき観点]**: 
- トークン有効期限のビジネス要件（24時間が適切か）
- 既存ユーザーへの移行計画
```


### レビュー後のフォローアップ
- **知識共有**: 重要な学びをチームWikiやドキュメントに記録
- **パターン認識**: 繰り返される問題の自動化検討（linter、カスタムルール）
- **メトリクス追跡**: レビュー時間、発見問題数、問題の種類を記録
- **振り返り**: 四半期ごとのレビュープロセス改善会議
- **ツール導入**: 自動化可能な指摘事項は積極的にツール化

### 自動化ツールとの連携
- **静的解析**: ESLint、Pylint、terraform fmt/validate
- **セキュリティ**: Snyk、tfsec、checkov
- **コード品質**: SonarQube、CodeClimate
- **型チェック**: TypeScript、mypy
- **フォーマット**: Prettier、Black、terraform fmt

## 🚫 セキュリティ・品質基準

### 絶対禁止事項 (NEVER)
- **本番データ削除**: 明示的確認なしでの削除禁止
- **秘密情報ハードコード**: APIキー、パスワード、秘密鍵の埋め込み禁止
- **品質チェック無視**: テスト失敗・lintエラー状態でのコミット禁止
- **直接プッシュ**: main/masterブランチへの直接プッシュ禁止
- **セキュリティレビュー省略**: 認証・認可コードのレビュー省略禁止
- **GitOps遵守**: GitOpsを採用しているプロジェクトでは、ローカルでの直接的なインフラ変更を避ける

### 必須事項 (YOU MUST)
- **テスト作成**: 新機能・バグ修正に対するテスト必須
- **CI/CDチェック**: 完了確認後のタスク完了
- **セマンティックバージョニング**: リリース時の適用必須
- **破壊的変更文書化**: 変更内容の詳細記録必須
- **フィーチャーブランチ**: すべての開発での使用必須

## 📊 効率化メトリクス・追跡

### 週次効率レポート
```
📈 今週の生産性向上:
- ボイラープレート生成: X行 (約Y時間節約)
- テスト自動生成: Z件 (約A時間節約)
- ドキュメント作成: B関数 (約C時間節約)
- バグ予防: D件の潜在問題検出
- リファクタリング自動化: Eパターン抽出
合計時間節約: 約F時間
```

### 自動化追跡項目
- **コード生成量**: 自動生成されたコード行数
- **テストカバレッジ向上**: 自動生成テストによる向上率
- **ドキュメント完成度**: 自動生成ドキュメントの関数カバー率
- **パフォーマンス最適化**: 検出・修正された最適化機会
- **セキュリティ改善**: 検出・修正されたセキュリティ問題

### 技術固有の効率化
- **Terraform**: plan結果の自動分析・影響範囲報告
- **BigQuery**: クエリコスト最適化提案

## 📝 Obsidianメモ記録

### グローバルメモコマンド
**重要な作業やタスクの完了時は、以下のコマンドでObsidianのデイリーノートに記録してください：**

```bash
# 使用方法
th "✅ 作業内容"
```

### 使用例
```bash
# 一般的な作業完了
th "✅ API認証機能を実装完了"

# 重要な気づき
th "💡 キャッシュ戦略の見直しが必要"

# 問題・課題
th "⚠️ デプロイ時にメモリ不足エラーが発生"

# ミーティング関連
th "✅ プロジェクトキックオフMTGの議事録作成完了"
```

### 記録タイミング
- タスク完了時
- 重要な決定事項
- エラー解決時
- ミーティング後の処理完了時
- その他、後で参照したい情報

**注意**: 
- このコマンドは~/src/github.com/ryosukesuto/obsidian-notesのデイリーノートに記録されます
- デイリーノートが存在しない場合は自動的に作成されます
- タイムスタンプが自動的に付与されます
- メモはデイリーノートの最後尾に追記されます（振り返りセクションの後）

## 📚 ドキュメント更新チェック機能

### 重要な作業の原則
**プッシュ前のドキュメント更新確認を忘れずに行う**

すべてのプロジェクトで以下の原則を適用してください：

1. **設定ファイル変更時の確認**
   - 設定ファイル（`.zshrc`, `config/*`, `*.json`など）を変更した場合
   - 新機能やコマンドを追加した場合
   - 既存の動作を変更した場合

2. **自動チェック項目**
   - 主要な設定ファイルの変更検出
   - 対応するドキュメントの更新が必要かチェック
   - プッシュ前に更新確認を促す

3. **手動確認が必要な場合**
   - 新機能の追加
   - 既存機能の仕様変更
   - 設定方法の変更
   - 依存関係の更新

### プッシュ前確認フロー

```bash
# 変更内容を確認
git diff --name-only HEAD~1

# 以下のファイルタイプが含まれる場合は要確認：
# - 設定ファイル: .zshrc, config/*, *.json, *.yaml
# - スクリプト: bin/*, install.sh, *.sh
# - カスタムコマンド: .claude/commands/*
# - 重要なファイル: README.md, CLAUDE.md
```

### ドキュメント更新が必要なパターン

#### Terraform プロジェクト（重点対象）
1. **リソース定義変更** → README.mdのリソース構成図・説明更新
2. **variables.tf更新** → 入力変数の説明とデフォルト値の文書化
3. **outputs.tf追加/変更** → 出力値の用途と使用例の記載
4. **provider設定変更** → バージョン要件とセットアップ手順の更新
5. **modules追加/変更** → モジュールの仕様と使用方法の文書化
6. **環境別設定ファイル** → 環境固有の設定手順と注意事項の記載
7. **IAMポリシー/ロール変更** → 必要な権限とセキュリティ考慮事項の説明

#### 一般プロジェクト
1. **設定ファイル変更** → README.mdやCLAUDE.mdの該当セクション更新
2. **新機能追加** → 使用方法と設定手順の文書化
3. **コマンド追加** → カスタムコマンドセクションの更新
4. **依存関係変更** → セットアップ手順の更新
5. **環境変数追加** → 環境設定セクションの更新

### 実装方法

#### Git Hookによる自動チェック

##### Terraformプロジェクト用（推奨）
プロジェクトのルートディレクトリに`.git/hooks/pre-push`を作成：

```bash
#!/bin/sh
# Terraformプロジェクト用ドキュメント更新チェック

# Terraform関連ファイルパターン
tf_patterns="\.tf$|\.tfvars$|\.tfvars\.json$|terraform\.lock\.hcl$"
# 重要な設定ファイル
config_patterns="\.terraformrc$|\.terraform\.d/.*|modules/.*"

# 変更されたファイルを確認
changed_tf_files=$(git diff --name-only HEAD~1 | grep -E "$tf_patterns")
changed_config_files=$(git diff --name-only HEAD~1 | grep -E "$config_patterns")

if [ -n "$changed_tf_files" ] || [ -n "$changed_config_files" ]; then
    echo "🏗️  Terraform関連ファイルの変更を検出しました："
    
    if [ -n "$changed_tf_files" ]; then
        echo ""
        echo "📄 Terraformファイル:"
        echo "$changed_tf_files" | sed 's/^/  - /'
    fi
    
    if [ -n "$changed_config_files" ]; then
        echo ""
        echo "⚙️  設定ファイル:"
        echo "$changed_config_files" | sed 's/^/  - /'
    fi
    
    echo ""
    echo "📚 以下のドキュメント更新を確認してください："
    echo "  ✅ README.md - リソース構成図・説明"
    echo "  ✅ variables.tf - 入力変数の説明"
    echo "  ✅ outputs.tf - 出力値の用途"
    echo "  ✅ provider要件 - バージョン・セットアップ手順"
    echo "  ✅ IAM権限 - 必要な権限とセキュリティ考慮事項"
    echo ""
    echo "💡 Terraformプロジェクトでは特に以下が重要です："
    echo "  - terraform planの実行結果"
    echo "  - 影響範囲の説明"
    echo "  - 環境別の設定手順"
    echo ""
    echo "継続しますか？ (Enter: 継続 / Ctrl+C: 中止)"
    read confirmation
fi
```

##### 一般プロジェクト用
```bash
#!/bin/sh
# 一般プロジェクト用ドキュメント更新チェック

# 変更対象ファイルパターン
config_patterns="\.zshrc|config/.*|\.json$|\.yaml$|bin/.*|install\.sh|\.claude/commands/.*"

# 変更されたファイルを確認
changed_files=$(git diff --name-only HEAD~1 | grep -E "$config_patterns")

if [ -n "$changed_files" ]; then
    echo "⚠️  ドキュメント更新の確認が必要です："
    echo "$changed_files"
    echo ""
    echo "関連ドキュメントの更新を確認してください："
    echo "- README.md"
    echo "- CLAUDE.md"
    echo "- 設定手順の文書化"
    echo ""
    echo "継続しますか？ (Enter: 継続 / Ctrl+C: 中止)"
    read confirmation
fi
```

#### Claude Code作業時のリマインダー

##### Terraformプロジェクト用フロー（重点）
1. **変更作業完了時**
   - `terraform plan`の実行と結果確認
   - 影響を受けるリソースの特定と文書化
   - IAM権限やセキュリティ影響の評価
   - 環境別設定の差異確認

2. **プッシュ前確認**
   - `git diff --name-only`でTerraformファイルの変更確認
   - variables.tf、outputs.tfの説明更新
   - README.mdのリソース構成図更新
   - terraform planの結果をPR説明に含める

3. **Terraform固有の文書化品質基準**
   - リソース依存関係の図解
   - 入力変数のvalidationルールと例
   - 出力値の用途と他モジュールでの使用例
   - デプロイ手順と注意事項
   - 環境間の設定差異説明

##### 一般プロジェクト用フロー
1. **変更作業完了時**
   - 変更内容の影響範囲を確認
   - 関連ドキュメントの更新要否を判断
   - 必要に応じてドキュメント更新を実施

2. **プッシュ前確認**
   - `git diff --name-only`で変更ファイルを確認
   - 設定ファイルが含まれる場合は文書化の確認
   - 新機能や重要な変更は必ず文書化

3. **文書化の品質基準**
   - 設定方法の明確な手順
   - 使用例とサンプルコード
   - 注意事項と制限事項
   - 既存設定からの変更点

### 効率的なドキュメント更新のコツ

#### Terraform特化のコツ
1. **段階的更新**
   - terraform planと並行してドキュメントを更新
   - モジュール設計時は事前にREADME構造を検討
   - リソース追加時は依存関係図も同時更新

2. **テンプレート活用**
   - 新しいTerraformモジュール用のREADMEテンプレート
   - variables.tf説明用のドキュメントテンプレート
   - IAM権限チェックリスト

3. **レビュー観点**
   - terraform planの結果理解
   - リソース影響範囲の説明
   - 環境間の設定差異説明
   - セキュリティ・コスト影響の記載

#### 一般プロジェクト用のコツ
1. **段階的更新**
   - 機能開発と並行してドキュメントを更新
   - 大きな変更は事前にドキュメント構造を検討

2. **テンプレート活用**
   - 新機能追加時のドキュメントテンプレート
   - 設定変更時のチェックリスト

3. **レビュー観点**
   - 初心者でも理解できる説明
   - 実際の使用例の提供
   - トラブルシューティング情報

## 🔄 段階的リファクタリング戦略

### 基本原則
**複数の改善項目がある場合は、必ずMVP方式で重要度順に一つずつ実装する**

すべてのリファクタリング作業で以下の原則を適用してください：

1. **単一PR原則**
   - 1つのPRには1つの改善項目のみを含める
   - 複数の改善を同時に行わない
   - 各PRは独立してレビュー・テスト可能にする

2. **重要度優先順位**
   - 緊急度と影響度のマトリックスで評価
   - セキュリティ > パフォーマンス > 保守性 > 可読性の順
   - ビジネス価値への影響を考慮

3. **段階的実装フロー**
   - 改善項目リストの作成と優先度付け
   - 最重要項目から順次実装
   - 前のPRがマージされてから次の項目に着手

### MVP実装フロー

#### Phase 1: 改善項目の特定と優先度付け
```markdown
📋 **リファクタリング計画**

## 🔍 発見された改善項目
1. **[緊急]** セキュリティ脆弱性の修正
2. **[重要]** パフォーマンスボトルネックの解消  
3. **[中程度]** コードの可読性改善
4. **[低]** 変数名の統一

## 📊 優先度評価基準
| 項目 | 緊急度 | 影響度 | 実装コスト | 優先度 |
|------|--------|--------|------------|--------|
| セキュリティ修正 | 高 | 高 | 低 | 🚨 最優先 |
| パフォーマンス改善 | 中 | 高 | 中 | ⚠️ 高 |
| 可読性改善 | 低 | 中 | 低 | 💡 中 |
| 変数名統一 | 低 | 低 | 低 | 📝 低 |

## 🚀 実装順序
1. **PR#1**: セキュリティ脆弱性の修正
2. **PR#2**: パフォーマンスボトルネックの解消
3. **PR#3**: コードの可読性改善  
4. **PR#4**: 変数名の統一
```

#### Phase 2: 個別PR実装

##### 最重要項目の実装（例）
```markdown
## PR#1: セキュリティ脆弱性の修正

### 🎯 **このPRの範囲**
- SQLインジェクション脆弱性の修正のみ
- 他の改善項目は含めない
- 最小限の変更で確実に修正

### ✅ **完了基準**
- [ ] セキュリティテストが通過
- [ ] 既存機能に影響なし
- [ ] コードレビュー完了
- [ ] 本番デプロイ確認

### 🚫 **意図的に含めない項目**
- パフォーマンス改善（次のPRで対応）
- 可読性改善（次々回のPRで対応）
- 変数名統一（将来のPRで対応）
```

### 重要度評価基準

#### 緊急度評価
- **🚨 緊急（即座対応）**: セキュリティ脆弱性、本番障害、データ損失リスク
- **⚠️ 高（1週間以内）**: パフォーマンス問題、ユーザー体験への影響
- **💡 中（1ヶ月以内）**: 保守性、開発効率への影響
- **📝 低（時間がある時）**: コードスタイル、命名規約

#### 影響度評価  
- **高**: ユーザーに直接影響、システム全体に影響
- **中**: 開発者の作業効率に影響、特定機能に影響
- **低**: コードの一部のみに影響

### PRチェック基準

#### マージ前必須チェック
1. **機能確認**
   - [ ] 対象機能が正常に動作する
   - [ ] 既存機能に影響がない
   - [ ] エラーハンドリングが適切

2. **品質確認**
   - [ ] テストが通過する
   - [ ] lint/フォーマットチェックが通過
   - [ ] コードレビューが完了

3. **ドキュメント確認**
   - [ ] README.mdが更新されている（必要に応じて）
   - [ ] 変更内容が適切に文書化されている
   - [ ] 次のPRの予定が明記されている

#### 次のPR着手条件
```markdown
✅ **PR#1完了確認**
- [ ] 本番環境にデプロイ済み
- [ ] 監視メトリクスで問題なし
- [ ] ユーザーからの問題報告なし
- [ ] 最低48時間の安定稼働確認

→ **PR#2（パフォーマンス改善）着手可能**
```

### Claude Code作業時のリファクタリングフロー

#### 1. 改善項目発見時
```markdown
🔍 **現状分析**: [現在のコード状況]
📋 **発見した改善項目**: 
1. [項目1 - 重要度：高]
2. [項目2 - 重要度：中]  
3. [項目3 - 重要度：低]

💡 **提案**: MVPアプローチで項目1から順次対応しませんか？
❓ **確認事項**: 他に優先すべき項目はありますか？
```

#### 2. 単一PR実装時
```markdown
🎯 **このPRの焦点**: [選択した改善項目]
🚫 **意図的に除外**: [他の改善項目リスト]
✅ **完了基準**: [明確な成功指標]
🔄 **次のステップ**: PR完了後の次の改善項目
```

#### 3. PR完了後のフォローアップ
```markdown
✅ **完了確認**: [実装した項目]
📊 **成果測定**: [改善効果の確認]
🔄 **次のPR準備**: [次の優先項目の詳細計画]
```

### 効果測定とフィードバック

#### リファクタリング効果の追跡
- **品質指標**: バグ発生率、テストカバレッジ
- **パフォーマンス指標**: レスポンス時間、リソース使用量  
- **開発効率指標**: 開発速度、コードレビュー時間
- **保守性指標**: 修正時間、新機能追加コスト

#### 段階的アプローチの利点
1. **リスク最小化**: 小さな変更によるリスク分散
2. **フィードバック活用**: 各段階での学習を次に活かす
3. **並行開発可能**: 他の開発と並行して進行可能
4. **ロールバック容易**: 問題発生時の影響を限定

## 🔒 セキュリティ注意事項
- パスワードや秘密鍵は記載しない
- 環境固有の情報は `.env.local` で管理
- APIトークンは `claude_desktop_config.json.local` で管理（gitignore済み）
- リポジトリ固有のルールは各プロジェクトのCLAUDE.mdを参照